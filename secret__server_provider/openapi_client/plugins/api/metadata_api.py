"""
    Secret Server Rest API

    REST API documentation for Secret Server. This document describes how to use the REST API. All requests require an authentication token; please see the <a href=\"../OAuth/\">authentication document</a> for more information. The <a href=\"swagger.json\">Swagger specification</a> for this API is also available.  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->  # noqa: E501

    The version of the OpenAPI document: 11.2.2
    Contact: info@authomize.com
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from plugins.api_client import ApiClient, Endpoint as _Endpoint
from plugins.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from plugins.model.authentication_failed_response import AuthenticationFailedResponse
from plugins.model.bad_request_response import BadRequestResponse
from plugins.model.internal_server_error_response import InternalServerErrorResponse
from plugins.model.metadata_create_args import MetadataCreateArgs
from plugins.model.metadata_delete_response import MetadataDeleteResponse
from plugins.model.metadata_field_section_summary_model import MetadataFieldSectionSummaryModel
from plugins.model.metadata_field_section_update_args import MetadataFieldSectionUpdateArgs
from plugins.model.metadata_model import MetadataModel
from plugins.model.metadata_update_args import MetadataUpdateArgs
from plugins.model.paging_of_metadata_field_section_summary_model import PagingOfMetadataFieldSectionSummaryModel
from plugins.model.paging_of_metadata_field_summary_model import PagingOfMetadataFieldSummaryModel
from plugins.model.paging_of_metadata_history_summary_model import PagingOfMetadataHistorySummaryModel
from plugins.model.paging_of_metadata_summary_model import PagingOfMetadataSummaryModel


class MetadataApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.metadata_service_create_metadata_endpoint = _Endpoint(
            settings={
                'response_type': (MetadataModel,),
                'auth': [
                    'BearerToken'
                ],
                'endpoint_path': '/v1/metadata/{itemType}/{itemId}',
                'operation_id': 'metadata_service_create_metadata',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'item_id',
                    'item_type',
                    'metadata_create_args',
                ],
                'required': [
                    'item_id',
                    'item_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'item_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'item_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'metadata_create_args':
                        (MetadataCreateArgs,),
                },
                'attribute_map': {
                    'item_id': 'itemId',
                    'item_type': 'itemType',
                },
                'location_map': {
                    'item_id': 'path',
                    'item_type': 'path',
                    'metadata_create_args': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.metadata_service_delete_metadata_endpoint = _Endpoint(
            settings={
                'response_type': (MetadataDeleteResponse,),
                'auth': [
                    'BearerToken'
                ],
                'endpoint_path': '/v1/metadata/{itemType}/{itemId}/{metadataItemDataId}',
                'operation_id': 'metadata_service_delete_metadata',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'item_id',
                    'item_type',
                    'metadata_item_data_id',
                ],
                'required': [
                    'item_id',
                    'item_type',
                    'metadata_item_data_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'item_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'item_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'metadata_item_data_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'item_id': 'itemId',
                    'item_type': 'itemType',
                    'metadata_item_data_id': 'metadataItemDataId',
                },
                'location_map': {
                    'item_id': 'path',
                    'item_type': 'path',
                    'metadata_item_data_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.metadata_service_get_field_sections_endpoint = _Endpoint(
            settings={
                'response_type': (PagingOfMetadataFieldSectionSummaryModel,),
                'auth': [
                    'BearerToken'
                ],
                'endpoint_path': '/v1/metadata/field-sections',
                'operation_id': 'metadata_service_get_field_sections',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'filter_item_id',
                    'filter_metadata_section_filter_id',
                    'filter_metadata_type',
                    'skip',
                    'sort_by_0_direction',
                    'sort_by_0_name',
                    'sort_by_0_priority',
                    'take',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'filter_item_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'filter_metadata_section_filter_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'filter_metadata_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'skip':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'sort_by_0_direction':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'sort_by_0_name':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'sort_by_0_priority':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'take':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'filter_item_id': 'filter.itemId',
                    'filter_metadata_section_filter_id': 'filter.metadataSectionFilterId',
                    'filter_metadata_type': 'filter.metadataType',
                    'skip': 'skip',
                    'sort_by_0_direction': 'sortBy[0].direction',
                    'sort_by_0_name': 'sortBy[0].name',
                    'sort_by_0_priority': 'sortBy[0].priority',
                    'take': 'take',
                },
                'location_map': {
                    'filter_item_id': 'query',
                    'filter_metadata_section_filter_id': 'query',
                    'filter_metadata_type': 'query',
                    'skip': 'query',
                    'sort_by_0_direction': 'query',
                    'sort_by_0_name': 'query',
                    'sort_by_0_priority': 'query',
                    'take': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.metadata_service_get_fields_endpoint = _Endpoint(
            settings={
                'response_type': (PagingOfMetadataFieldSummaryModel,),
                'auth': [
                    'BearerToken'
                ],
                'endpoint_path': '/v1/metadata/fields',
                'operation_id': 'metadata_service_get_fields',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.metadata_service_search_metadata_endpoint = _Endpoint(
            settings={
                'response_type': (PagingOfMetadataSummaryModel,),
                'auth': [
                    'BearerToken'
                ],
                'endpoint_path': '/v1/metadata',
                'operation_id': 'metadata_service_search_metadata',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'filter_item_id',
                    'filter_meta_data_field_id',
                    'filter_metadata_type',
                    'skip',
                    'sort_by_0_direction',
                    'sort_by_0_name',
                    'sort_by_0_priority',
                    'take',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'filter_item_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'filter_meta_data_field_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'filter_metadata_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'skip':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'sort_by_0_direction':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'sort_by_0_name':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'sort_by_0_priority':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'take':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'filter_item_id': 'filter.itemId',
                    'filter_meta_data_field_id': 'filter.metaDataFieldId',
                    'filter_metadata_type': 'filter.metadataType',
                    'skip': 'skip',
                    'sort_by_0_direction': 'sortBy[0].direction',
                    'sort_by_0_name': 'sortBy[0].name',
                    'sort_by_0_priority': 'sortBy[0].priority',
                    'take': 'take',
                },
                'location_map': {
                    'filter_item_id': 'query',
                    'filter_meta_data_field_id': 'query',
                    'filter_metadata_type': 'query',
                    'skip': 'query',
                    'sort_by_0_direction': 'query',
                    'sort_by_0_name': 'query',
                    'sort_by_0_priority': 'query',
                    'take': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.metadata_service_search_metadata_history_endpoint = _Endpoint(
            settings={
                'response_type': (PagingOfMetadataHistorySummaryModel,),
                'auth': [
                    'BearerToken'
                ],
                'endpoint_path': '/v1/metadata/history',
                'operation_id': 'metadata_service_search_metadata_history',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'is_exporting',
                    'filter_end_date',
                    'filter_item_id',
                    'filter_meta_data_field_id',
                    'filter_metadata_type',
                    'filter_start_date',
                    'skip',
                    'sort_by_0_direction',
                    'sort_by_0_name',
                    'sort_by_0_priority',
                    'take',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'is_exporting':
                        (bool,),
                    'filter_end_date':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'filter_item_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'filter_meta_data_field_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'filter_metadata_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'filter_start_date':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'skip':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'sort_by_0_direction':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'sort_by_0_name':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'sort_by_0_priority':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'take':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'is_exporting': 'isExporting',
                    'filter_end_date': 'filter.endDate',
                    'filter_item_id': 'filter.itemId',
                    'filter_meta_data_field_id': 'filter.metaDataFieldId',
                    'filter_metadata_type': 'filter.metadataType',
                    'filter_start_date': 'filter.startDate',
                    'skip': 'skip',
                    'sort_by_0_direction': 'sortBy[0].direction',
                    'sort_by_0_name': 'sortBy[0].name',
                    'sort_by_0_priority': 'sortBy[0].priority',
                    'take': 'take',
                },
                'location_map': {
                    'is_exporting': 'query',
                    'filter_end_date': 'query',
                    'filter_item_id': 'query',
                    'filter_meta_data_field_id': 'query',
                    'filter_metadata_type': 'query',
                    'filter_start_date': 'query',
                    'skip': 'query',
                    'sort_by_0_direction': 'query',
                    'sort_by_0_name': 'query',
                    'sort_by_0_priority': 'query',
                    'take': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.metadata_service_update_metadata_endpoint = _Endpoint(
            settings={
                'response_type': (MetadataModel,),
                'auth': [
                    'BearerToken'
                ],
                'endpoint_path': '/v1/metadata/{itemType}/{itemId}',
                'operation_id': 'metadata_service_update_metadata',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'item_id',
                    'item_type',
                    'metadata_update_args',
                ],
                'required': [
                    'item_id',
                    'item_type',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'item_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'item_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'metadata_update_args':
                        (MetadataUpdateArgs,),
                },
                'attribute_map': {
                    'item_id': 'itemId',
                    'item_type': 'itemType',
                },
                'location_map': {
                    'item_id': 'path',
                    'item_type': 'path',
                    'metadata_update_args': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.metadata_service_update_metadata_field_section_endpoint = _Endpoint(
            settings={
                'response_type': (MetadataFieldSectionSummaryModel,),
                'auth': [
                    'BearerToken'
                ],
                'endpoint_path': '/v1/metadata/field-sections/{fieldSectionId}',
                'operation_id': 'metadata_service_update_metadata_field_section',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'field_section_id',
                    'item_id',
                    'item_type',
                    'metadata_field_section_update_args',
                ],
                'required': [
                    'field_section_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'field_section_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'item_id':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'item_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'metadata_field_section_update_args':
                        (MetadataFieldSectionUpdateArgs,),
                },
                'attribute_map': {
                    'field_section_id': 'fieldSectionId',
                    'item_id': 'itemId',
                    'item_type': 'itemType',
                },
                'location_map': {
                    'field_section_id': 'path',
                    'item_id': 'query',
                    'item_type': 'query',
                    'metadata_field_section_update_args': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )

    def metadata_service_create_metadata(
        self,
        item_id,
        item_type,
        **kwargs
    ):
        """Create Metadata  # noqa: E501

        Create or update a metadata field for an item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metadata_service_create_metadata(item_id, item_type, async_req=True)
        >>> result = thread.get()

        Args:
            item_id (bool, date, datetime, dict, float, int, list, str, none_type): The item ID of the entity to which this metadata is associated
            item_type (bool, date, datetime, dict, float, int, list, str, none_type): The type of entity to which this metadata is associated

        Keyword Args:
            metadata_create_args (MetadataCreateArgs): args. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            MetadataModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['item_id'] = \
            item_id
        kwargs['item_type'] = \
            item_type
        return self.metadata_service_create_metadata_endpoint.call_with_http_info(**kwargs)

    def metadata_service_delete_metadata(
        self,
        item_id,
        item_type,
        metadata_item_data_id,
        **kwargs
    ):
        """Delete Metadata  # noqa: E501

        Deletes the metadata value and all history for that item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metadata_service_delete_metadata(item_id, item_type, metadata_item_data_id, async_req=True)
        >>> result = thread.get()

        Args:
            item_id (bool, date, datetime, dict, float, int, list, str, none_type): The item ID of the entity to which this metadata is associated
            item_type (bool, date, datetime, dict, float, int, list, str, none_type): The type of entity to which this metadata is associated
            metadata_item_data_id (bool, date, datetime, dict, float, int, list, str, none_type): The sequence ID of the metadata record to delete

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            MetadataDeleteResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['item_id'] = \
            item_id
        kwargs['item_type'] = \
            item_type
        kwargs['metadata_item_data_id'] = \
            metadata_item_data_id
        return self.metadata_service_delete_metadata_endpoint.call_with_http_info(**kwargs)

    def metadata_service_get_field_sections(
        self,
        **kwargs
    ):
        """Get metadata field sections  # noqa: E501

        Return all of the metadata sections that have metadata for a specific item.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metadata_service_get_field_sections(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            filter_item_id (bool, date, datetime, dict, float, int, list, str, none_type): Return sections that have metadata for this specific item id.  MetadataType will be required.. [optional]
            filter_metadata_section_filter_id (bool, date, datetime, dict, float, int, list, str, none_type): Return a specific Metadata Section Field ID.. [optional]
            filter_metadata_type (bool, date, datetime, dict, float, int, list, str, none_type): Only return metadata for a specific type of item.  Will also required an ItemId. [optional]
            skip (bool, date, datetime, dict, float, int, list, str, none_type): Number of records to skip before taking results. [optional]
            sort_by_0_direction (bool, date, datetime, dict, float, int, list, str, none_type): Sort direction. [optional]
            sort_by_0_name (bool, date, datetime, dict, float, int, list, str, none_type): Sort field name. [optional]
            sort_by_0_priority (bool, date, datetime, dict, float, int, list, str, none_type): Priority index. Sorts with lower values are executed earlier. [optional]
            take (bool, date, datetime, dict, float, int, list, str, none_type): Maximum number of records to include in results. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            PagingOfMetadataFieldSectionSummaryModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.metadata_service_get_field_sections_endpoint.call_with_http_info(**kwargs)

    def metadata_service_get_fields(
        self,
        **kwargs
    ):
        """Get metadata fields  # noqa: E501

        Returns a list of all of the metadata sections and fields that exist  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metadata_service_get_fields(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            PagingOfMetadataFieldSummaryModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.metadata_service_get_fields_endpoint.call_with_http_info(**kwargs)

    def metadata_service_search_metadata(
        self,
        **kwargs
    ):
        """Search metadata  # noqa: E501

        Search, filter, sort, and page metadata  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metadata_service_search_metadata(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            filter_item_id (bool, date, datetime, dict, float, int, list, str, none_type): Will only return metadata for this entity ID.  MetadataType will also be required.. [optional]
            filter_meta_data_field_id (bool, date, datetime, dict, float, int, list, str, none_type): Return a specific metadata field. [optional]
            filter_metadata_type (bool, date, datetime, dict, float, int, list, str, none_type): Will only return metadata for this type.  ItemId will also be required.. [optional]
            skip (bool, date, datetime, dict, float, int, list, str, none_type): Number of records to skip before taking results. [optional]
            sort_by_0_direction (bool, date, datetime, dict, float, int, list, str, none_type): Sort direction. [optional]
            sort_by_0_name (bool, date, datetime, dict, float, int, list, str, none_type): Sort field name. [optional]
            sort_by_0_priority (bool, date, datetime, dict, float, int, list, str, none_type): Priority index. Sorts with lower values are executed earlier. [optional]
            take (bool, date, datetime, dict, float, int, list, str, none_type): Maximum number of records to include in results. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            PagingOfMetadataSummaryModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.metadata_service_search_metadata_endpoint.call_with_http_info(**kwargs)

    def metadata_service_search_metadata_history(
        self,
        **kwargs
    ):
        """Search metadata history  # noqa: E501

        Search, filter, sort, and page metadata history  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metadata_service_search_metadata_history(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            is_exporting (bool): isExporting. [optional]
            filter_end_date (bool, date, datetime, dict, float, int, list, str, none_type): Only return history metadata values that were entered before this time. [optional]
            filter_item_id (bool, date, datetime, dict, float, int, list, str, none_type): Will only return metadata for this entity ID.  MetadataType will also be required.. [optional]
            filter_meta_data_field_id (bool, date, datetime, dict, float, int, list, str, none_type): Return a specific metadata field. [optional]
            filter_metadata_type (bool, date, datetime, dict, float, int, list, str, none_type): Will only return metadata for this type.  ItemId will also be required.. [optional]
            filter_start_date (bool, date, datetime, dict, float, int, list, str, none_type): Only return history metadata values that were entered after this time. [optional]
            skip (bool, date, datetime, dict, float, int, list, str, none_type): Number of records to skip before taking results. [optional]
            sort_by_0_direction (bool, date, datetime, dict, float, int, list, str, none_type): Sort direction. [optional]
            sort_by_0_name (bool, date, datetime, dict, float, int, list, str, none_type): Sort field name. [optional]
            sort_by_0_priority (bool, date, datetime, dict, float, int, list, str, none_type): Priority index. Sorts with lower values are executed earlier. [optional]
            take (bool, date, datetime, dict, float, int, list, str, none_type): Maximum number of records to include in results. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            PagingOfMetadataHistorySummaryModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.metadata_service_search_metadata_history_endpoint.call_with_http_info(**kwargs)

    def metadata_service_update_metadata(
        self,
        item_id,
        item_type,
        **kwargs
    ):
        """Update or Create Metadata  # noqa: E501

        Update or create a metadata field for an item  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metadata_service_update_metadata(item_id, item_type, async_req=True)
        >>> result = thread.get()

        Args:
            item_id (bool, date, datetime, dict, float, int, list, str, none_type): The item ID of the entity to which this metadata is associated
            item_type (bool, date, datetime, dict, float, int, list, str, none_type): The type of entity to which this metadata is associated

        Keyword Args:
            metadata_update_args (MetadataUpdateArgs): args. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            MetadataModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['item_id'] = \
            item_id
        kwargs['item_type'] = \
            item_type
        return self.metadata_service_update_metadata_endpoint.call_with_http_info(**kwargs)

    def metadata_service_update_metadata_field_section(
        self,
        field_section_id,
        **kwargs
    ):
        """Update a metadata field section  # noqa: E501

        Update a metadata field section  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metadata_service_update_metadata_field_section(field_section_id, async_req=True)
        >>> result = thread.get()

        Args:
            field_section_id (bool, date, datetime, dict, float, int, list, str, none_type): The section ID of the field to which this metadata is associated

        Keyword Args:
            item_id (bool, date, datetime, dict, float, int, list, str, none_type): The item ID of the entity to which this metadata is associated. [optional]
            item_type (bool, date, datetime, dict, float, int, list, str, none_type): The type of entity to which this metadata is associated. [optional]
            metadata_field_section_update_args (MetadataFieldSectionUpdateArgs): args. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            MetadataFieldSectionSummaryModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['field_section_id'] = \
            field_section_id
        return self.metadata_service_update_metadata_field_section_endpoint.call_with_http_info(**kwargs)

